<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.557">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="LASER Institute">
<meta name="dcterms.date" content="2024-07-13">

<title>Module 4: Case Study</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="kt-4-case-study_files/libs/clipboard/clipboard.min.js"></script>
<script src="kt-4-case-study_files/libs/quarto-html/quarto.js"></script>
<script src="kt-4-case-study_files/libs/quarto-html/popper.min.js"></script>
<script src="kt-4-case-study_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="kt-4-case-study_files/libs/quarto-html/anchor.min.js"></script>
<link href="kt-4-case-study_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="kt-4-case-study_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="kt-4-case-study_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="kt-4-case-study_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="kt-4-case-study_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="kt-4-case-study_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="kt-4-case-study_files/libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#deep-knowledge-tracing" id="toc-deep-knowledge-tracing" class="nav-link active" data-scroll-target="#deep-knowledge-tracing">Deep Knowledge Tracing</a>
  <ul>
  <li><a href="#review-the-research" id="toc-review-the-research" class="nav-link" data-scroll-target="#review-the-research">Review the Research</a></li>
  <li><a href="#dkt-implementation" id="toc-dkt-implementation" class="nav-link" data-scroll-target="#dkt-implementation">DKT implementation</a></li>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a></li>
  <li><a href="#data-preparation" id="toc-data-preparation" class="nav-link" data-scroll-target="#data-preparation">Data preparation</a></li>
  <li><a href="#hyperparameter-tuning" id="toc-hyperparameter-tuning" class="nav-link" data-scroll-target="#hyperparameter-tuning">Hyperparameter tuning</a></li>
  <li><a href="#code-wrangling" id="toc-code-wrangling" class="nav-link" data-scroll-target="#code-wrangling">Code wrangling</a></li>
  <li><a href="#getting-and-using-the-correctness-predictions" id="toc-getting-and-using-the-correctness-predictions" class="nav-link" data-scroll-target="#getting-and-using-the-correctness-predictions">Getting and using the correctness predictions</a></li>
  <li><a href="#averaging-correctness-predictions" id="toc-averaging-correctness-predictions" class="nav-link" data-scroll-target="#averaging-correctness-predictions">Averaging correctness predictions</a></li>
  <li><a href="#statistical-comparisons" id="toc-statistical-comparisons" class="nav-link" data-scroll-target="#statistical-comparisons">Statistical comparisons</a></li>
  <li><a href="#some-final-notes" id="toc-some-final-notes" class="nav-link" data-scroll-target="#some-final-notes">Some final notes</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Module 4: Case Study</h1>
<p class="subtitle lead">Deep Knowledge Tracing</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>LASER Institute </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 13, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="deep-knowledge-tracing" class="level2">
<h2 class="anchored" data-anchor-id="deep-knowledge-tracing">Deep Knowledge Tracing</h2>
<p>As discussed in the lecture, most DKT-family papers focus on introducing a new algorithm, running that algorithm on standard datasets, and discussing how the new algorithm achieves better AUC values. For this case study, you will instead focus on running an existing algorithm on a new dataset. While this activity will focus on one implementation of DKT, the same general process will be broadly applicable to most implementations of DKT-family algorithms - and many implementations of other knowledge tracing algorithms as well.</p>
<p>The case study will loosely follow Baker et al.&nbsp;(in press), which uses DKT’s correctness predictions to produce estimates of students’ skill levels.</p>
<section id="review-the-research" class="level3">
<h3 class="anchored" data-anchor-id="review-the-research">Review the Research</h3>
<p>Baker, R., Scruggs, R., Pavlik, P.I., McLaren, B.M., Liu, Z. (in press) How Well Do Contemporary Knowledge Tracing Algorithms Predict the Knowledge Carried Out of a Digital Learning Game? To appear in <em>Educational Technology Research &amp; Development</em> (<a href="https://www.google.com/url?q=https%3A%2F%2Flearninganalytics.upenn.edu%2Fryanbaker%2Fetrd-scruggs.pdf">link</a>)</p>
<p><strong>Abstract</strong>: Despite considerable advances in knowledge tracing algorithms, educational technologies that use this technology typically continue to use older algorithms, such as Bayesian Knowledge Tracing. One key reason for this is that contemporary knowledge tracing algorithms primarily infer next-problem correctness in the learning system, but do not attempt to infer the knowledge the student can carry out of the system, information more useful for teachers. The ability of knowledge tracing algorithms to predict problem correctness using data from intelligent tutoring systems has been extensively researched, but data from outcomes other than next-problem correctness have received less attention. In addition, there has been limited use of knowledge tracing algorithms in games, because algorithms that do attempt to infer knowledge from answer correctness are often too simple to capture the more complex evidence of learning within games. In this study, data from a digital learning game, Decimal Point, was used to compare ten knowledge tracing algorithms’ ability to predict students’ knowledge carried outside the learning system - measured here by posttest scores - given their game activity. All Opportunities Averaged (AOA), a method proposed by Scruggs, Baker, &amp; McLaren (2020) was used to convert correctness predictions to knowledge estimates, which were also compared to the built-in estimates from algorithms that produced them. Although statistical testing was not feasible for these data, three algorithms tended to perform better than the others: Dynamic Key-Value Memory Networks, Logistic Knowledge Tracing, and a multivariate version of Elo. Algorithms’ built-in estimates of student ability underperformed estimates produced by AOA, suggesting that some algorithms may be better at estimating performance than ability. Theoretical and methodological challenges related to comparing knowledge estimates with hypothesis testing are also discussed.</p>
<p>Following Scruggs et al.&nbsp;(2020), this paper continued testing whether DKT-family algorithms’ more-accurate correctness predictions could be used to produce more accurate estimates of student knowledge than either built-in student ability estimates or averaged correctness predictions from other algorithms.</p>
</section>
<section id="dkt-implementation" class="level3">
<h3 class="anchored" data-anchor-id="dkt-implementation">DKT implementation</h3>
<p><span class="citation" data-cites="scruggs2023well">Scruggs et al. (<a href="#ref-scruggs2023well" role="doc-biblioref">2023</a>)</span> used an implementation of DKT from Yeung and Yeung (2018), but that implementation requires deprecated Python libraries, so this case study will instead use a more modern implementation from Gervet et al.&nbsp;(2020). In addition to being easier to run, this implementation also exports correctness predictions automatically.</p>
<p><strong>Colab note</strong>: For fitting DKT, you’ll need to be using a Colab runtime with a GPU. You can complete the earlier steps without a GPU, but switching the runtime type will reset the runtime environment, deleting all data.</p>
</section>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p>Like most implementations of DKT-family algorithms, this implementation is intended to be run on the datasets reported in the paper. For this exercise, you will be working to run DKT on another dataset. You can either work with your own dataset, or, if you don’t have a dataset in mind, you could work with a small dataset from Bruce McLaren’s Decimal Point system, taken from Scruggs et al.&nbsp;(2020).</p>
<p>As mentioned in the lecture, DKT-family algorithms tend to perform better on larger datasets, but for this case study, a smaller dataset should work fine - the Decimal Point data contains about 70K attempts. If you’re interested in using your own dataset, read through the next section and consider the possible problems and how they may apply to your data. Take a look at one of the datasets included with the DKT implementation as well to see if your dataset contains the same information - user IDs, item IDs, correctness, and some sort of skill ID should probably be included.</p>
<div id="995dd2ae" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># First, clone the Git repository. This implementation also requires TensorboardX, so</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># we install that here.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>git clone https:<span class="op">//</span>github.com<span class="op">/</span>theophilegervet<span class="op">/</span>learner<span class="op">-</span>performance<span class="op">-</span>prediction</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install tensorboardX</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>mv learner<span class="op">-</span>performance<span class="op">-</span>prediction<span class="op">/*</span> .</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>fatal: destination path 'learner-performance-prediction' already exists and is not an empty directory.
Defaulting to user installation because normal site-packages is not writeable
Requirement already satisfied: tensorboardX in /cloud/python/lib/python3.8/site-packages (2.6.2.2)
Requirement already satisfied: numpy in /cloud/python/lib/python3.8/site-packages (from tensorboardX) (1.24.4)
Requirement already satisfied: packaging in /cloud/python/lib/python3.8/site-packages (from tensorboardX) (23.2)
Requirement already satisfied: protobuf&gt;=3.20 in /cloud/python/lib/python3.8/site-packages (from tensorboardX) (5.27.2)

[notice] A new release of pip is available: 24.0 -&gt; 24.1.2
[notice] To update, run: /opt/python/3.8.17/bin/python3.8 -m pip install --upgrade pip
mv: cannot stat 'learner-performance-prediction/*': No such file or directory</code></pre>
</div>
</div>
</section>
<section id="data-preparation" class="level3">
<h3 class="anchored" data-anchor-id="data-preparation">Data preparation</h3>
<p>Take a look at the <code>prepare_data.py</code> file. That file preprocesses data from Assistments and several other data sets. <code>prepare_kddcup10</code> in that file is a long function, but it checks for several possible problems in the dataset. If you’re using your own data, it’s probably worth checking for such issues. Here’s a partial list of things to think about:</p>
<ul>
<li><p>How many attempts must a student make to be included in the dataset?</p></li>
<li><p>Have all practice problems - problems with extra help or scaffolding as compared to the rest of the activity - been removed?</p></li>
<li><p>Have all items without an answer attempt been removed?</p></li>
<li><p>Have all item attempts after the first attempt been removed?</p></li>
<li><p>Is the data sorted in chronological order? If attempts are very fast, are the timestamps high-resolution enough to allow for proper sorting?</p></li>
<li><p>If you’re using a sparse dataset with relatively few attempts per item, it’s good to check that all items appear in the training set. Some implementations crash if previously unseen items appear in the test set.</p></li>
</ul>
<p>Note that by default <code>prepare_data.py</code> constructs a train split and a test split. This implementation constructs its validation split from the train split. If you want to do hyperparameter tuning, you may want to edit <code>train_dkt2.py</code> to make sure that the validation split is the same for each combination of hyperparameters.</p>
</section>
<section id="hyperparameter-tuning" class="level3">
<h3 class="anchored" data-anchor-id="hyperparameter-tuning">Hyperparameter tuning</h3>
<p><span class="citation" data-cites="scruggs2023well">Scruggs et al. (<a href="#ref-scruggs2023well" role="doc-biblioref">2023</a>)</span> does not conduct hyperparameter tuning. In our experience with DKT-family algorithms, hyperparameter tuning can give some benefit, but rarely leads to large performance gains. However, if you are interested in hyperparameter tuning, Gervet et al.&nbsp;(2020) mentions that they tested the following hyperparameter values: [50, 100, 200] for embedding size and hidden layer dimension and [1,2] for number of hidden layers.</p>
<p>Hyperparameters can be set with command-line arguments when running the implementation; see <code>train_dkt2.py</code> for more information.</p>
</section>
<section id="code-wrangling" class="level3">
<h3 class="anchored" data-anchor-id="code-wrangling">Code wrangling</h3>
<p>Using prepare_kddcup as a starting point, edit your dataset or the Python code so that the code will format your data properly. Run prepare_data.py on your dataset.</p>
<p>If you’re working with the Decimal Point data, note that there are no timestamps, but the code expects them to be present to sort the data and de-duplicate attempts. The data is already sorted properly; you can either remove the portions of the code that work with timestamps or add dummy timestamps.</p>
<p>Explanation To complete this, the student needs to:</p>
<p>Look at the Python code for prepare_kddcup.</p>
<p>Figure out which columns are referred to (and which column names are hardcoded vs the ones that can be passed in.</p>
<p>Change either the code or data so that they match.</p>
<p>Figure out how to handle problem IDs - in the Decimal Point data, they can just use problem numbers.</p>
<p>Change “correct” and “incorrect” to 0 and 1.</p>
<p>Remove references to timestamps (or add dummies).</p>
<p>Edit dataset names and create a data folder so the code processes their dataset.</p>
<p>Run prepare_data.py on their dataset.</p>
<p>Once you’re done modifying prepare_data.py, go ahead and run it on your data.</p>
<p><code>!python prepare_data_modified.py --dataset decimal</code></p>
<p><code># Now that the data is ready, it's time to train DKT. Change the dataset name as # needed.</code></p>
<p><code>Make sure you're running on a GPU-enabled runtime.</code></p>
<p><code>!python train_dkt2.py --dataset decimal</code></p>
<p><code>Once it finishes training, it will compute the AUC on the test set.</code></p>
</section>
<section id="getting-and-using-the-correctness-predictions" class="level3">
<h3 class="anchored" data-anchor-id="getting-and-using-the-correctness-predictions">Getting and using the correctness predictions</h3>
<p>This implementation of DKT adds a column with its correctness prediction (<code>DKT2</code>) directly to the test data CSV. If you’re working with another DKT implementation or another DKT-family algorithm, it may be more complicated to export correctness predictions. In particular, some algorithms may reorder students or attempts, making it difficult to connect correctness predictions back to their corresponding attempts.</p>
<p>Once you have the correctness predictions attached to attempts, it’s easy to compute AUC, RMSE, or other fit statistics. Here, we will use Pandas to load the data and scikit-learn to compute the statistics.</p>
<p><code>import pandas as pd</code></p>
<p><code>df = pd.read_csv("data/decimal/preprocessed_data_test.csv", sep="\t")</code></p>
<p><code>df</code></p>
<p><code>The dataframe should now have a 'DKT2' column with correctness predictions.</code></p>
<p><code>from sklearn.metrics import mean_squared_error, roc_auc_score print("RMSE:", mean_squared_error(df['correct'], df['DKT2'])**0.5) print("AUC:", roc_auc_score(df['correct'], df['DKT2']))</code></p>
<p><code>Look at the RMSE and AUC values. Do you think DKT does a good job predicting correctness on the dataset?</code></p>
</section>
<section id="averaging-correctness-predictions" class="level3">
<h3 class="anchored" data-anchor-id="averaging-correctness-predictions">Averaging correctness predictions</h3>
<p>In Baker et al.&nbsp;(in press), instead of looking at AUC values, the correctness predictions were averaged to produce skill estimates. That can be done with Pandas’ <code>groupby</code> function:</p>
<p><code>df['skill_estimate'] = df.groupby(["user_id", "skill_id"])['DKT2'].transform('mean') # This groups the dataframe by user_id and skill_id, then for each group, it computes the mean of the "DKT2" column. # 'transform' is used to duplicate the resulting means so that they are the same length as the original dataframe, # allowing them to be assigned to a new column.</code></p>
<p><code>results = df.drop_duplicates(['user_id', 'skill_id']) # Drop duplicates to keep one row per user and skill.</code></p>
<p><code>results.drop(["item_id", "correct", "timestamp"], axis=1, inplace=True) # And remove the extra columns, giving a list of skill estimates for each skill for each user. # Of course, if a user did not attempt a skill, since they were never in the original dataframe, they # are not listed here either.</code></p>
<p><code>results</code></p>
<p>In this case study, we will stop here, not comparing the skill estimates to posttest scores - in part due to the statistical issues mentioned below.</p>
<p>Baker et al.&nbsp;use DKT’s correctness predictions to generate skill estimates as done here. Can you think of another use for the correctness predictions? Are there other ways to use them to say things about either an individual student’s learning, more general skill learning (like BKT’s guess and slip parameters), or behavior in the learning system?</p>
</section>
<section id="statistical-comparisons" class="level3">
<h3 class="anchored" data-anchor-id="statistical-comparisons">Statistical comparisons</h3>
<p>As discussed in Baker et al.&nbsp;(in press), comparisons between student-level skill estimates are statistically complex and it can be difficult to avoid violating statistical assumptions. These statistical challenges may be one reason why there are few comparisons of knowledge tracing algorithms’ skill estimates.</p>
<p>As this case study does not use any posttest scores and focuses on one implementation of DKT, those statistical risks are moot, but they are worth keeping in mind if you plan to compare skill-level estimates from knowledge tracing algorithms, or if you compare knowledge tracing algorithms using metrics other than AUC, RMSE, or similar dataset-level statistics.</p>
</section>
<section id="some-final-notes" class="level3">
<h3 class="anchored" data-anchor-id="some-final-notes">Some final notes</h3>
<p>As discussed in the lecture, we are skeptical about the value of item clustering or skill discovery in DKT-family models. If you’re interested in exploring that further, there are relatively few papers to refer to, but Ding and Larson’s work (2019, 2021) is worth reading; they discuss the internal structure of DKT-family models at some length.</p>
<p>The correctness predictions in Baker et al.&nbsp;(in press) were computed as students worked through the learning system. That means that, when computing skill estimates, a prediction about a student’s second attempt was considered just as meaningful as their last, even though the posttest was not given until students had finished working with the learning system.</p>
<p>We have found in two data sets that those estimates are more accurate than estimates that were computed after all of a student’s activity in the learning system. Can you think of reasons why this might be the case?。</p>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-scruggs2023well" class="csl-entry" role="listitem">
Scruggs, Richard, Ryan S Baker, Philip I Pavlik Jr, Bruce M McLaren, and Ziyang Liu. 2023. <span>“How Well Do Contemporary Knowledge Tracing Algorithms Predict the Knowledge Carried Out of a Digital Learning Game?”</span> <em>Educational Technology Research and Development</em> 71 (3): 901–18.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>